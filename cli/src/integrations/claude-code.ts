/**
 * Claude Code Integration
 *
 * Generates a PreToolUse hook script for Claude Code that routes
 * tool calls through ACP's /acp/intercept endpoint.
 *
 * Claude Code tools are mapped to ACP tool names:
 *   Bash       → shell:bash
 *   Write      → file:write
 *   Edit       → file:write
 *   Read       → file:read
 *   WebFetch   → http:fetch
 *   WebSearch  → http:search
 *   Glob       → file:read
 *   Grep       → file:read
 *   NotebookEdit → file:write
 */

import fs from 'node:fs';
import path from 'node:path';

const TOOL_MAP: Record<string, { tool: string; kind: string }> = {
  Bash:         { tool: 'shell:bash',   kind: 'shell' },
  Write:        { tool: 'file:write',   kind: 'file' },
  Edit:         { tool: 'file:write',   kind: 'file' },
  Read:         { tool: 'file:read',    kind: 'file' },
  WebFetch:     { tool: 'http:fetch',   kind: 'http' },
  WebSearch:    { tool: 'http:search',  kind: 'http' },
  Glob:         { tool: 'file:read',    kind: 'file' },
  Grep:         { tool: 'file:read',    kind: 'file' },
  NotebookEdit: { tool: 'file:write',   kind: 'file' },
  Task:         { tool: 'claude:task',  kind: 'hook' },
};

/**
 * Generate the Claude Code PreToolUse hook script.
 * Returns the path to the generated script.
 */
export function generateClaudeCodeHook(acpPort: number, outputDir: string): string {
  fs.mkdirSync(outputDir, { recursive: true });

  const hookPath = path.join(outputDir, 'claude-code-hook.sh');

  const toolMapJson = JSON.stringify(TOOL_MAP);

  const script = `#!/bin/bash
# ACP PreToolUse Hook for Claude Code
# Generated by: acp setup claude-code
#
# Reads tool call JSON from stdin, maps to ACP tool name,
# POSTs to /acp/intercept, exits 0 (allow) or 2 (block).

set -euo pipefail

ACP_PORT=${acpPort}

# Read the tool call from stdin
INPUT=$(cat)

# Use Node.js to map and call ACP (avoids curl dependency)
node -e "
const http = require('http');
const input = JSON.parse(process.argv[1]);
const toolName = input.tool_name || '';
const toolInput = input.tool_input || {};

const TOOL_MAP = ${toolMapJson};

const mapping = TOOL_MAP[toolName];
if (!mapping) {
  // Unknown tool — allow by default (Claude Code internal tools)
  process.exit(0);
}

const payload = JSON.stringify({
  kind: mapping.kind,
  tool: mapping.tool,
  arguments: {
    ...toolInput,
    claude_tool: toolName,
  },
});

const req = http.request({
  hostname: '127.0.0.1',
  port: ${acpPort},
  path: '/acp/intercept',
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    'Content-Length': Buffer.byteLength(payload),
  },
  timeout: 30000,
}, (res) => {
  let body = '';
  res.on('data', (c) => body += c);
  res.on('end', () => {
    try {
      const result = JSON.parse(body);
      if (result.allowed) {
        process.exit(0);
      } else {
        console.error('acp: ' + (result.reason || 'Denied'));
        process.exit(2);
      }
    } catch {
      process.exit(0); // Parse error — allow
    }
  });
});

req.on('error', () => {
  console.error('acp: could not reach ACP proxy — denying');
  process.exit(2);
});

req.on('timeout', () => {
  req.destroy();
  console.error('acp: timeout — denying');
  process.exit(2);
});

req.write(payload);
req.end();
" "\$INPUT"
`;

  fs.writeFileSync(hookPath, script, { mode: 0o755 });
  return hookPath;
}

/**
 * Get the Claude Code settings.json hook configuration.
 */
export function getClaudeCodeSettings(hookPath: string): Record<string, unknown> {
  return {
    hooks: {
      PreToolUse: [
        {
          matcher: '.*',
          command: hookPath,
        },
      ],
    },
  };
}
